### YamlMime:JavaMember
uid: com.azure.cosmos.implementation.guava25.collect.Maps.uniqueIndex*
fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex
name: <K,V>uniqueIndex
nameWithType: Maps.<K,V>uniqueIndex
members:
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(java.lang.Iterable<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
  name: <K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
  nameWithType: Maps.<K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
  summary: |-
    Returns a map with the given <code>values</code>, indexed by keys derived from those values. In
     other words, each input value produces an entry in the map whose key is the result of applying
     <code>keyFunction</code> to that value. These entries appear in the same order as the input values.
     Example usage:

     <pre><code>
     Color red = new Color("red", 255, 0, 0);
     ...
     ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);

     Map<String, Color> colorForName =
         uniqueIndex(allColors, toStringFunction());
     assertThat(colorForName).containsEntry("red", red);
     </code></pre>

     <p>If your index may associate multiple values with each key, use <xref uid="Multimaps#index(Iterable, Function)" data-throw-if-not-resolved="false">Multimaps.index</xref>.
  parameters:
  - description: the values to use when constructing the <code>Map</code>
    name: values
    type: <xref href="java.lang.Iterable?alt=java.lang.Iterable&text=Iterable" data-throw-if-not-resolved="False" />&lt;<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;
  - description: the function used to produce the key for each value
    name: keyFunction
    type: <xref href="com.azure.cosmos.implementation.guava25.base.Function?alt=com.azure.cosmos.implementation.guava25.base.Function&text=Function" data-throw-if-not-resolved="False" />&lt;<xref href="? super V?alt=? super V&text=? super V" data-throw-if-not-resolved="False" />,<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />&gt;
  syntax: public static ImmutableMap<K,V> <K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
  returns:
    description: |-
      a map mapping the result of evaluating the function <code>keyFunction</code> on each value
           in the input collection to that value
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.ImmutableMap?alt=com.azure.cosmos.implementation.guava25.collect.ImmutableMap&text=ImmutableMap" data-throw-if-not-resolved="False" />&lt;<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />,<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(java.util.Iterator<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
  name: <K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
  nameWithType: Maps.<K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
  summary: |-
    Returns a map with the given <code>values</code>, indexed by keys derived from those values. In
     other words, each input value produces an entry in the map whose key is the result of applying
     <code>keyFunction</code> to that value. These entries appear in the same order as the input values.
     Example usage:

     <pre><code>
     Color red = new Color("red", 255, 0, 0);
     ...
     Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();

     Map<String, Color> colorForName =
         uniqueIndex(allColors, toStringFunction());
     assertThat(colorForName).containsEntry("red", red);
     </code></pre>

     <p>If your index may associate multiple values with each key, use <xref uid="Multimaps#index(Iterator, Function)" data-throw-if-not-resolved="false">Multimaps.index</xref>.
  parameters:
  - description: the values to use when constructing the <code>Map</code>
    name: values
    type: <xref href="java.util.Iterator?alt=java.util.Iterator&text=Iterator" data-throw-if-not-resolved="False" />&lt;<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;
  - description: the function used to produce the key for each value
    name: keyFunction
    type: <xref href="com.azure.cosmos.implementation.guava25.base.Function?alt=com.azure.cosmos.implementation.guava25.base.Function&text=Function" data-throw-if-not-resolved="False" />&lt;<xref href="? super V?alt=? super V&text=? super V" data-throw-if-not-resolved="False" />,<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />&gt;
  syntax: public static ImmutableMap<K,V> <K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
  returns:
    description: |-
      a map mapping the result of evaluating the function <code>keyFunction</code> on each value
           in the input collection to that value
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.ImmutableMap?alt=com.azure.cosmos.implementation.guava25.collect.ImmutableMap&text=ImmutableMap" data-throw-if-not-resolved="False" />&lt;<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />,<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;
type: method
metadata: {}
package: com.azure.cosmos.implementation.guava25.collect
artifact: com.azure:azure-cosmos:4.3.2-beta.2
