### YamlMime:JavaMember
uid: com.azure.cosmos.implementation.guava25.collect.Sets.cartesianProduct*
fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct
name: <B>cartesianProduct
nameWithType: Sets.<B>cartesianProduct
members:
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(java.util.List<? extends java.util.Set<? extends B>>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(List<? extends Set<? extends B>> sets)
  name: <B>cartesianProduct(List<? extends Set<? extends B>> sets)
  nameWithType: Sets.<B>cartesianProduct(List<? extends Set<? extends B>> sets)
  summary: |-
    Returns every possible list that can be formed by choosing one element from each of the given
     sets in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
     product</a>" of the sets. For example:

     <pre><code>
     Sets.cartesianProduct(ImmutableList.of(
         ImmutableSet.of(1, 2),
         ImmutableSet.of("A", "B", "C")))
     </code></pre>

     <p>returns a set containing six lists:

     <ul>
       <li><code>ImmutableList.of(1, "A")</code>
       <li><code>ImmutableList.of(1, "B")</code>
       <li><code>ImmutableList.of(1, "C")</code>
       <li><code>ImmutableList.of(2, "A")</code>
       <li><code>ImmutableList.of(2, "B")</code>
       <li><code>ImmutableList.of(2, "C")</code>
     </ul>

     <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
     products that you would get from nesting for loops:

     <pre><code>
     for (B b0 : sets.get(0)) {
       for (B b1 : sets.get(1)) {
         ...
         ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
         // operate on tuple
       }
     }
     </code></pre>

     <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
     all are provided (an empty list), the resulting Cartesian product has one element, an empty
     list (counter-intuitive, but mathematically consistent).

     <p><i>Performance notes:</i> while the cartesian product of sets of size <code>m, n, p</code> is a
     set of size <code>m x n x p</code>, its actual memory consumption is much smaller. When the
     cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
     iterated are the individual lists created, and these are not retained after iteration.
  parameters:
  - description: |-
      the sets to choose elements from, in the order that the elements chosen from those
           sets should appear in the resulting lists
    name: sets
    type: <xref href="java.util.List?alt=java.util.List&text=List" data-throw-if-not-resolved="False" />&lt;<xref href="? extends java.util.Set?alt=? extends java.util.Set&text=Set" data-throw-if-not-resolved="False" />&lt;<xref href="? extends B?alt=? extends B&text=? extends B" data-throw-if-not-resolved="False" />&gt;&gt;
  syntax: public static Set<List<B>> <B>cartesianProduct(List<? extends Set<? extends B>> sets)
  returns:
    description: the Cartesian product, as an immutable set containing immutable lists
    type: <xref href="java.util.Set?alt=java.util.Set&text=Set" data-throw-if-not-resolved="False" />&lt;<xref href="java.util.List?alt=java.util.List&text=List" data-throw-if-not-resolved="False" />&lt;<xref href="B?alt=B&text=B" data-throw-if-not-resolved="False" />&gt;&gt;
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(java.util.Set<? extends B>...)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(Set<? extends B>[] sets)
  name: <B>cartesianProduct(Set<? extends B>[] sets)
  nameWithType: Sets.<B>cartesianProduct(Set<? extends B>[] sets)
  summary: |-
    Returns every possible list that can be formed by choosing one element from each of the given
     sets in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
     product</a>" of the sets. For example:

     <pre><code>
     Sets.cartesianProduct(
         ImmutableSet.of(1, 2),
         ImmutableSet.of("A", "B", "C"))
     </code></pre>

     <p>returns a set containing six lists:

     <ul>
       <li><code>ImmutableList.of(1, "A")</code>
       <li><code>ImmutableList.of(1, "B")</code>
       <li><code>ImmutableList.of(1, "C")</code>
       <li><code>ImmutableList.of(2, "A")</code>
       <li><code>ImmutableList.of(2, "B")</code>
       <li><code>ImmutableList.of(2, "C")</code>
     </ul>

     <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
     products that you would get from nesting for loops:

     <pre><code>
     for (B b0 : sets.get(0)) {
       for (B b1 : sets.get(1)) {
         ...
         ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
         // operate on tuple
       }
     }
     </code></pre>

     <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
     all are provided (an empty list), the resulting Cartesian product has one element, an empty
     list (counter-intuitive, but mathematically consistent).

     <p><i>Performance notes:</i> while the cartesian product of sets of size <code>m, n, p</code> is a
     set of size <code>m x n x p</code>, its actual memory consumption is much smaller. When the
     cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
     iterated are the individual lists created, and these are not retained after iteration.
  parameters:
  - description: |-
      the sets to choose elements from, in the order that the elements chosen from those
           sets should appear in the resulting lists
    name: sets
    type: <xref href="java.util.Set?alt=java.util.Set&text=Set" data-throw-if-not-resolved="False" />&lt;<xref href="? extends B?alt=? extends B&text=? extends B" data-throw-if-not-resolved="False" />&gt;[]
  syntax: public static Set<List<B>> <B>cartesianProduct(Set<? extends B>[] sets)
  returns:
    description: the Cartesian product, as an immutable set containing immutable lists
    type: <xref href="java.util.Set?alt=java.util.Set&text=Set" data-throw-if-not-resolved="False" />&lt;<xref href="java.util.List?alt=java.util.List&text=List" data-throw-if-not-resolved="False" />&lt;<xref href="B?alt=B&text=B" data-throw-if-not-resolved="False" />&gt;&gt;
type: method
metadata: {}
package: com.azure.cosmos.implementation.guava25.collect
artifact: com.azure:azure-cosmos:4.3.2-beta.2
