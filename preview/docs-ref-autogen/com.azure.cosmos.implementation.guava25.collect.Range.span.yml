### YamlMime:JavaMember
uid: com.azure.cosmos.implementation.guava25.collect.Range.span*
fullName: com.azure.cosmos.implementation.guava25.collect.Range<C>.span
name: span
nameWithType: Range<C>.span
members:
- uid: com.azure.cosmos.implementation.guava25.collect.Range.span(com.azure.cosmos.implementation.guava25.collect.Range<C>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Range<C>.span(Range<C> other)
  name: span(Range<C> other)
  nameWithType: Range<C>.span(Range<C> other)
  summary: |-
    Returns the minimal range that <xref uid="#encloses" data-throw-if-not-resolved="false">encloses</xref> both this range and <code>
     other</code>. For example, the span of <code>[1..3]</code> and <code>(5..7)</code> is <code>[1..7)</code>.

     <p><i>If</i> the input ranges are <xref uid="#isConnected" data-throw-if-not-resolved="false">connected</xref>, the returned range can
     also be called their <i>union</i>. If they are not, note that the span might contain values
     that are not contained in either input range.

     <p>Like <xref uid="#intersection(Range)" data-throw-if-not-resolved="false">intersection</xref>, this operation is commutative, associative
     and idempotent. Unlike it, it is always well-defined for any two input ranges.
  parameters:
  - name: other
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.Range?alt=com.azure.cosmos.implementation.guava25.collect.Range&text=Range" data-throw-if-not-resolved="False" />&lt;<xref href="C?alt=C&text=C" data-throw-if-not-resolved="False" />&gt;
  syntax: public Range<C> span(Range<C> other)
  returns:
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.Range?alt=com.azure.cosmos.implementation.guava25.collect.Range&text=Range" data-throw-if-not-resolved="False" />&lt;<xref href="C?alt=C&text=C" data-throw-if-not-resolved="False" />&gt;
type: method
metadata: {}
package: com.azure.cosmos.implementation.guava25.collect
artifact: com.azure:azure-cosmos:4.3.2-beta.2
