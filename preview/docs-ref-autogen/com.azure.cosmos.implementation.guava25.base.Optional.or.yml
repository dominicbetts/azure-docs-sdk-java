### YamlMime:JavaMember
uid: com.azure.cosmos.implementation.guava25.base.Optional.or*
fullName: com.azure.cosmos.implementation.guava25.base.Optional<T>.or
name: or
nameWithType: Optional<T>.or
members:
- uid: com.azure.cosmos.implementation.guava25.base.Optional.or(T)
  fullName: com.azure.cosmos.implementation.guava25.base.Optional<T>.or(T defaultValue)
  name: or(T defaultValue)
  nameWithType: Optional<T>.or(T defaultValue)
  summary: |-
    Returns the contained instance if it is present; <code>defaultValue</code> otherwise. If no default
     value should be required because the instance is known to be present, use <xref uid="#get()" data-throw-if-not-resolved="false">#get()</xref>
     instead. For a default value of <code>null</code>, use <xref uid="#orNull" data-throw-if-not-resolved="false">#orNull</xref>.

     <p>Note about generics: The signature <code>public T or(T defaultValue)</code> is overly
     restrictive. However, the ideal signature, <code>public <S super T> S or(S)</code>, is not legal
     Java. As a result, some sensible operations involving subtypes are compile errors:

     <pre><code>
     Optional<Integer> optionalInt = getSomeOptionalInt();
     Number value = optionalInt.or(0.5); // error

     FluentIterable<? extends Number> numbers = getSomeNumbers();
     Optional<? extends Number> first = numbers.first();
     Number value = first.or(0.5); // error
     </code></pre>

     <p>As a workaround, it is always safe to cast an <code>Optional<? extends T></code> to <code>
     Optional<T></code>. Casting either of the above example <code>Optional</code> instances to <code>
     Optional<Number></code> (where <code>Number</code> is the desired output type) solves the problem:

     <pre><code>
     Optional<Number> optionalInt = (Optional) getSomeOptionalInt();
     Number value = optionalInt.or(0.5); // fine

     FluentIterable<? extends Number> numbers = getSomeNumbers();
     Optional<Number> first = (Optional) numbers.first();
     Number value = first.or(0.5); // fine
     </code></pre>

     <p><b>Comparison to <code>java.util.Optional</code>:</b> this method is similar to Java 8's <code>
     Optional.orElse</code>, but will not accept <code>null</code> as a <code>defaultValue</code> (<xref uid="#orNull" data-throw-if-not-resolved="false">#orNull</xref>
     must be used instead). As a result, the value returned by this method is guaranteed non-null,
     which is not the case for the <code>java.util</code> equivalent.
  parameters:
  - name: defaultValue
    type: <xref href="T?alt=T&text=T" data-throw-if-not-resolved="False" />
  syntax: public abstract T or(T defaultValue)
  returns:
    type: <xref href="T?alt=T&text=T" data-throw-if-not-resolved="False" />
- uid: com.azure.cosmos.implementation.guava25.base.Optional.or(com.azure.cosmos.implementation.guava25.base.Optional<? extends T>)
  fullName: com.azure.cosmos.implementation.guava25.base.Optional<T>.or(Optional<? extends T> secondChoice)
  name: or(Optional<? extends T> secondChoice)
  nameWithType: Optional<T>.or(Optional<? extends T> secondChoice)
  summary: |-
    Returns this <code>Optional</code> if it has a value present; <code>secondChoice</code> otherwise.

     <p><b>Comparison to <code>java.util.Optional</code>:</b> this method has no equivalent in Java 8's
     <code>Optional</code> class; write <code>thisOptional.isPresent() ? thisOptional : secondChoice</code>
     instead.
  parameters:
  - name: secondChoice
    type: <xref href="com.azure.cosmos.implementation.guava25.base.Optional?alt=com.azure.cosmos.implementation.guava25.base.Optional&text=Optional" data-throw-if-not-resolved="False" />&lt;<xref href="? extends T?alt=? extends T&text=? extends T" data-throw-if-not-resolved="False" />&gt;
  syntax: public abstract Optional<T> or(Optional<? extends T> secondChoice)
  returns:
    type: <xref href="com.azure.cosmos.implementation.guava25.base.Optional?alt=com.azure.cosmos.implementation.guava25.base.Optional&text=Optional" data-throw-if-not-resolved="False" />&lt;<xref href="T?alt=T&text=T" data-throw-if-not-resolved="False" />&gt;
- uid: com.azure.cosmos.implementation.guava25.base.Optional.or(com.azure.cosmos.implementation.guava25.base.Supplier<? extends T>)
  fullName: com.azure.cosmos.implementation.guava25.base.Optional<T>.or(Supplier<? extends T> supplier)
  name: or(Supplier<? extends T> supplier)
  nameWithType: Optional<T>.or(Supplier<? extends T> supplier)
  summary: |-
    Returns the contained instance if it is present; <code>supplier.get()</code> otherwise.

     <p><b>Comparison to <code>java.util.Optional</code>:</b> this method is similar to Java 8's <code>
     Optional.orElseGet</code>, except when <code>supplier</code> returns <code>null</code>. In this case this
     method throws an exception, whereas the Java 8 method returns the <code>null</code> to the caller.
  parameters:
  - name: supplier
    type: <xref href="com.azure.cosmos.implementation.guava25.base.Supplier?alt=com.azure.cosmos.implementation.guava25.base.Supplier&text=Supplier" data-throw-if-not-resolved="False" />&lt;<xref href="? extends T?alt=? extends T&text=? extends T" data-throw-if-not-resolved="False" />&gt;
  syntax: public abstract T or(Supplier<? extends T> supplier)
  returns:
    type: <xref href="T?alt=T&text=T" data-throw-if-not-resolved="False" />
type: method
metadata: {}
package: com.azure.cosmos.implementation.guava25.base
artifact: com.azure:azure-cosmos:4.3.2-beta.2
