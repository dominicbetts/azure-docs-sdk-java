### YamlMime:JavaMember
uid: com.azure.cosmos.implementation.guava25.collect.Maps.synchronizedNavigableMap*
fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedNavigableMap
name: <K,V>synchronizedNavigableMap
nameWithType: Maps.<K,V>synchronizedNavigableMap
members:
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedNavigableMap(java.util.NavigableMap<K,V>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
  name: <K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
  nameWithType: Maps.<K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
  summary: |-
    Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In
     order to guarantee serial access, it is critical that <b>all</b> access to the backing
     navigable map is accomplished through the returned navigable map (or its views).

     <p>It is imperative that the user manually synchronize on the returned navigable map when
     iterating over any of its collection views, or the collections views of any of its <code>
     descendingMap</code>, <code>subMap</code>, <code>headMap</code> or <code>tailMap</code> views.

     <pre><code>
     NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());

     // Needn't be in synchronized block
     NavigableSet<K> set = map.navigableKeySet();

     synchronized (map) { // Synchronizing on map, not set!
       Iterator<K> it = set.iterator(); // Must be in synchronized block
       while (it.hasNext()) {
         foo(it.next());
       }
     }
     </code></pre>

     <p>or:

     <pre><code>
     NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());
     NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);

     // Needn't be in synchronized block
     NavigableSet<K> set2 = map2.descendingKeySet();

     synchronized (map) { // Synchronizing on map, not map2 or set2!
       Iterator<K> it = set2.iterator(); // Must be in synchronized block
       while (it.hasNext()) {
         foo(it.next());
       }
     }
     </code></pre>

     <p>Failure to follow this advice may result in non-deterministic behavior.

     <p>The returned navigable map will be serializable if the specified navigable map is
     serializable.
  parameters:
  - description: the navigable map to be "wrapped" in a synchronized navigable map.
    name: navigableMap
    type: <xref href="java.util.NavigableMap?alt=java.util.NavigableMap&text=NavigableMap" data-throw-if-not-resolved="False" />&lt;<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />,<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;
  syntax: public static NavigableMap<K,V> <K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
  returns:
    description: a synchronized view of the specified navigable map.
    type: <xref href="java.util.NavigableMap?alt=java.util.NavigableMap&text=NavigableMap" data-throw-if-not-resolved="False" />&lt;<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />,<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;
type: method
metadata: {}
package: com.azure.cosmos.implementation.guava25.collect
artifact: com.azure:azure-cosmos:4.3.2-beta.2
