### YamlMime:JavaType
uid: com.azure.cosmos.implementation.guava25.collect.Multimap
fullName: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
name: Multimap<K,V>
nameWithType: Multimap<K,V>
summary: |-
  A collection that maps keys to values, similar to <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref>, but in which each key may be associated with *multiple* values. You can visualize the contents of a multimap either as a map from keys to *nonempty* collections of values:

   *  a \\u2192 1, 2
   *  b \\u2192 3

  ... or as a single "flattened" collection of key-value pairs:

   *  a \\u2192 1
   *  a \\u2192 2
   *  b \\u2192 3

  **Important:** although the first interpretation resembles how most multimaps are *implemented*, the design of the `Multimap` API is based on the *second* form. So, using the multimap shown above as an example, the <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.size" data-throw-if-not-resolved="false">#size</xref> is `3`, not `2`, and the <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.values" data-throw-if-not-resolved="false">#values</xref> collection is `[1, 2, 3]`, not `[[1, 2], [3]]`. For those times when the first style is more useful, use the multimap's <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.asMap" data-throw-if-not-resolved="false">#asMap</xref> view (or create a `Map>` in the first place).

  ### Example ###

  The following code:

  ```java
  ListMultimap multimap = ArrayListMultimap.create();
   for (President pres : US_PRESIDENTS_IN_ORDER) {
     multimap.put(pres.firstName(), pres.lastName());
   }
   for (String firstName : multimap.keySet()) {
     List lastNames = multimap.get(firstName);
     out.println(firstName + ": " + lastNames);
   }
  ```

  ... produces output such as:

  ```java
  Zachary: [Taylor]
   John: [Adams, Adams, Tyler, Kennedy]  // Remember, Quincy!
   George: [Washington, Bush, Bush]
   Grover: [Cleveland, Cleveland]        // Two, non-consecutive terms, rep'ing NJ!
   ...
  ```

  ### Views ###

  Much of the power of the multimap API comes from the *view collections* it provides. These always reflect the latest state of the multimap itself. When they support modification, the changes are *write-through* (they automatically update the backing multimap). These view collections are:

   *  <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.asMap" data-throw-if-not-resolved="false">#asMap</xref>, mentioned above
   *  <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.keys" data-throw-if-not-resolved="false">#keys</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.keySet" data-throw-if-not-resolved="false">#keySet</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.values" data-throw-if-not-resolved="false">#values</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.entries" data-throw-if-not-resolved="false">#entries</xref>, which are similar to the corresponding view collections of <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref>
   *  and, notably, even the collection returned by <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.get" data-throw-if-not-resolved="false">get(key)</xref> is an active view of the values corresponding to `key`

  The collections returned by the <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues" data-throw-if-not-resolved="false">replaceValues</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll" data-throw-if-not-resolved="false">removeAll</xref> methods, which contain values that have just been removed from the multimap, are naturally *not* views.

  ### Subinterfaces ###

  Instead of using the `Multimap` interface directly, prefer the subinterfaces <xref uid="com.azure.cosmos.implementation.guava25.collect.ListMultimap" data-throw-if-not-resolved="false">ListMultimap</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.SetMultimap" data-throw-if-not-resolved="false">SetMultimap</xref>. These take their names from the fact that the collections they return from `get` behave like (and, of course, implement) <xref uid="java.util.List" data-throw-if-not-resolved="false">List</xref> and <xref uid="java.util.Set" data-throw-if-not-resolved="false">Set</xref>, respectively.

  For example, the "presidents" code snippet above used a `ListMultimap`; if it had used a `SetMultimap` instead, two presidents would have vanished, and last names might or might not appear in chronological order.

  **Warning:** instances of type `Multimap` may not implement <xref uid="java.lang.Object.equals" data-throw-if-not-resolved="false">Object#equals</xref> in the way you expect. Multimaps containing the same key-value pairs, even in the same order, may or may not be equal and may or may not have the same `hashCode`. The recommended subinterfaces provide much stronger guarantees.

  ### Comparison to a map of collections ###

  Multimaps are commonly used in places where a `Map>` would otherwise have appeared. The differences include:

   *  There is no need to populate an empty collection before adding an entry with <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.put" data-throw-if-not-resolved="false">put</xref>.
   *  `get` never returns `null`, only an empty collection.
   *  A key is contained in the multimap if and only if it maps to at least one value. Any operation that causes a key to have zero associated values has the effect of *removing* that key from the multimap.
   *  The total entry count is available as <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.size" data-throw-if-not-resolved="false">#size</xref>.
   *  Many complex operations become easier; for example, `Collections.min(multimap.values())` finds the smallest value across all keys.

  ### Implementations ###

  As always, prefer the immutable implementations, <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap" data-throw-if-not-resolved="false">ImmutableListMultimap</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap" data-throw-if-not-resolved="false">ImmutableSetMultimap</xref>. General-purpose mutable implementations are listed above under "All Known Implementing Classes". You can also create a *custom* multimap, backed by any `Map` and <xref uid="java.util.Collection" data-throw-if-not-resolved="false">Collection</xref> types, using the <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.newMultimap" data-throw-if-not-resolved="false">Multimaps.newMultimap</xref> family of methods. Finally, another popular way to obtain a multimap is using <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.index" data-throw-if-not-resolved="false">Multimaps.index</xref>. See the <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps" data-throw-if-not-resolved="false">Multimaps</xref> class for these and other static utilities related to multimaps.

  ### Other Notes ###

  As with `Map`, the behavior of a `Multimap` is not specified if key objects already present in the multimap change in a manner that affects `equals` comparisons. Use caution if mutable objects are used as keys in a `Multimap`.

  All methods that modify the multimap are optional. The view collections returned by the multimap may or may not be modifiable. Any modification method that is not supported will throw <xref uid="java.lang.UnsupportedOperationException" data-throw-if-not-resolved="false">UnsupportedOperationException</xref>.

  See the Guava User Guide article on [ `Multimap`][_Multimap].


  [_Multimap]: https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap
syntax: public interface Multimap<K,V>
methods:
- com.azure.cosmos.implementation.guava25.collect.Multimap.asMap()
- com.azure.cosmos.implementation.guava25.collect.Multimap.clear()
- com.azure.cosmos.implementation.guava25.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)
- com.azure.cosmos.implementation.guava25.collect.Multimap.containsKey(java.lang.Object)
- com.azure.cosmos.implementation.guava25.collect.Multimap.containsValue(java.lang.Object)
- com.azure.cosmos.implementation.guava25.collect.Multimap.entries()
- com.azure.cosmos.implementation.guava25.collect.Multimap.equals(java.lang.Object)
- com.azure.cosmos.implementation.guava25.collect.Multimap.forEach(java.util.function.BiConsumer<? super K,? super V>)
- com.azure.cosmos.implementation.guava25.collect.Multimap.get(K)
- com.azure.cosmos.implementation.guava25.collect.Multimap.hashCode()
- com.azure.cosmos.implementation.guava25.collect.Multimap.isEmpty()
- com.azure.cosmos.implementation.guava25.collect.Multimap.keySet()
- com.azure.cosmos.implementation.guava25.collect.Multimap.keys()
- com.azure.cosmos.implementation.guava25.collect.Multimap.put(K,V)
- com.azure.cosmos.implementation.guava25.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)
- com.azure.cosmos.implementation.guava25.collect.Multimap.putAll(com.azure.cosmos.implementation.guava25.collect.Multimap<? extends K,? extends V>)
- com.azure.cosmos.implementation.guava25.collect.Multimap.remove(java.lang.Object,java.lang.Object)
- com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll(java.lang.Object)
- com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues(K,java.lang.Iterable<? extends V>)
- com.azure.cosmos.implementation.guava25.collect.Multimap.size()
- com.azure.cosmos.implementation.guava25.collect.Multimap.values()
type: interface
typeParameters:
- name: K
- name: V
metadata: {}
package: com.azure.cosmos.implementation.guava25.collect
artifact: com.azure:azure-cosmos:4.3.2-beta.2
