### YamlMime:JavaMember
uid: com.azure.cosmos.implementation.guava25.collect.Streams.mapWithIndex*
fullName: com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex
name: <R>mapWithIndex
nameWithType: Streams.<R>mapWithIndex
members:
- uid: com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(java.util.stream.DoubleStream,com.azure.cosmos.implementation.guava25.collect.Streams.DoubleFunctionWithIndex<R>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)
  name: <R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)
  nameWithType: Streams.<R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)
  summary: |-
    Returns a stream consisting of the results of applying the given function to the elements of
     <code>stream</code> and their indexes in the stream. For example,

     <pre><code>
     mapWithIndex(
         DoubleStream.of(0, 1, 2),
         (x, index) -> x + ":" + index)
     </code></pre>

     <p>...would return <code>Stream.of("0.0:0", "1.0:1", "2.0:2")</code>.

     <p>The resulting stream is <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
     if and only if <code>stream</code> was efficiently splittable and its underlying spliterator
     reported <xref uid="Spliterator#SUBSIZED" data-throw-if-not-resolved="false">Spliterator#SUBSIZED</xref>. This is generally the case if the underlying stream
     comes from a data structure supporting efficient indexed random access, typically an array or
     list.

     <p>The order of the resulting stream is defined if and only if the order of the original stream
     was defined.
  parameters:
  - name: stream
    type: <xref href="java.util.stream.DoubleStream?alt=java.util.stream.DoubleStream&text=DoubleStream" data-throw-if-not-resolved="False" />
  - name: function
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.Streams.DoubleFunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.DoubleFunctionWithIndex&text=DoubleFunctionWithIndex" data-throw-if-not-resolved="False" />&lt;<xref href="R?alt=R&text=R" data-throw-if-not-resolved="False" />&gt;
  syntax: public static Stream<R> <R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)
  returns:
    type: <xref href="java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream" data-throw-if-not-resolved="False" />&lt;<xref href="R?alt=R&text=R" data-throw-if-not-resolved="False" />&gt;
- uid: com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(java.util.stream.IntStream,com.azure.cosmos.implementation.guava25.collect.Streams.IntFunctionWithIndex<R>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)
  name: <R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)
  nameWithType: Streams.<R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)
  summary: |-
    Returns a stream consisting of the results of applying the given function to the elements of
     <code>stream</code> and their indexes in the stream. For example,

     <pre><code>
     mapWithIndex(
         IntStream.of(0, 1, 2),
         (i, index) -> i + ":" + index)
     </code></pre>

     <p>...would return <code>Stream.of("0:0", "1:1", "2:2")</code>.

     <p>The resulting stream is <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
     if and only if <code>stream</code> was efficiently splittable and its underlying spliterator
     reported <xref uid="Spliterator#SUBSIZED" data-throw-if-not-resolved="false">Spliterator#SUBSIZED</xref>. This is generally the case if the underlying stream
     comes from a data structure supporting efficient indexed random access, typically an array or
     list.

     <p>The order of the resulting stream is defined if and only if the order of the original stream
     was defined.
  parameters:
  - name: stream
    type: <xref href="java.util.stream.IntStream?alt=java.util.stream.IntStream&text=IntStream" data-throw-if-not-resolved="False" />
  - name: function
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.Streams.IntFunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.IntFunctionWithIndex&text=IntFunctionWithIndex" data-throw-if-not-resolved="False" />&lt;<xref href="R?alt=R&text=R" data-throw-if-not-resolved="False" />&gt;
  syntax: public static Stream<R> <R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)
  returns:
    type: <xref href="java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream" data-throw-if-not-resolved="False" />&lt;<xref href="R?alt=R&text=R" data-throw-if-not-resolved="False" />&gt;
- uid: com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(java.util.stream.LongStream,com.azure.cosmos.implementation.guava25.collect.Streams.LongFunctionWithIndex<R>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)
  name: <R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)
  nameWithType: Streams.<R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)
  summary: |-
    Returns a stream consisting of the results of applying the given function to the elements of
     <code>stream</code> and their indexes in the stream. For example,

     <pre><code>
     mapWithIndex(
         LongStream.of(0, 1, 2),
         (i, index) -> i + ":" + index)
     </code></pre>

     <p>...would return <code>Stream.of("0:0", "1:1", "2:2")</code>.

     <p>The resulting stream is <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
     if and only if <code>stream</code> was efficiently splittable and its underlying spliterator
     reported <xref uid="Spliterator#SUBSIZED" data-throw-if-not-resolved="false">Spliterator#SUBSIZED</xref>. This is generally the case if the underlying stream
     comes from a data structure supporting efficient indexed random access, typically an array or
     list.

     <p>The order of the resulting stream is defined if and only if the order of the original stream
     was defined.
  parameters:
  - name: stream
    type: <xref href="java.util.stream.LongStream?alt=java.util.stream.LongStream&text=LongStream" data-throw-if-not-resolved="False" />
  - name: function
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.Streams.LongFunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.LongFunctionWithIndex&text=LongFunctionWithIndex" data-throw-if-not-resolved="False" />&lt;<xref href="R?alt=R&text=R" data-throw-if-not-resolved="False" />&gt;
  syntax: public static Stream<R> <R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)
  returns:
    type: <xref href="java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream" data-throw-if-not-resolved="False" />&lt;<xref href="R?alt=R&text=R" data-throw-if-not-resolved="False" />&gt;
- uid: com.azure.cosmos.implementation.guava25.collect.Streams.<T,R>mapWithIndex(java.util.stream.Stream<T>,com.azure.cosmos.implementation.guava25.collect.Streams.FunctionWithIndex<? super T,? extends R>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Streams.<T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)
  name: <T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)
  nameWithType: Streams.<T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)
  summary: |-
    Returns a stream consisting of the results of applying the given function to the elements of
     <code>stream</code> and their indices in the stream. For example,

     <pre><code>
     mapWithIndex(
         Stream.of("a", "b", "c"),
         (str, index) -> str + ":" + index)
     </code></pre>

     <p>would return <code>Stream.of("a:0", "b:1", "c:2")</code>.

     <p>The resulting stream is <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
     if and only if <code>stream</code> was efficiently splittable and its underlying spliterator
     reported <xref uid="Spliterator#SUBSIZED" data-throw-if-not-resolved="false">Spliterator#SUBSIZED</xref>. This is generally the case if the underlying stream
     comes from a data structure supporting efficient indexed random access, typically an array or
     list.

     <p>The order of the resulting stream is defined if and only if the order of the original stream
     was defined.
  parameters:
  - name: stream
    type: <xref href="java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream" data-throw-if-not-resolved="False" />&lt;<xref href="T?alt=T&text=T" data-throw-if-not-resolved="False" />&gt;
  - name: function
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.Streams.FunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.FunctionWithIndex&text=FunctionWithIndex" data-throw-if-not-resolved="False" />&lt;<xref href="? super T?alt=? super T&text=? super T" data-throw-if-not-resolved="False" />,<xref href="? extends R?alt=? extends R&text=? extends R" data-throw-if-not-resolved="False" />&gt;
  syntax: public static Stream<R> <T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)
  returns:
    type: <xref href="java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream" data-throw-if-not-resolved="False" />&lt;<xref href="R?alt=R&text=R" data-throw-if-not-resolved="False" />&gt;
type: method
metadata: {}
package: com.azure.cosmos.implementation.guava25.collect
artifact: com.azure:azure-cosmos:4.3.2-beta.2
