### YamlMime:JavaMember
uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.newMultimap*
fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newMultimap
name: <K,V>newMultimap
nameWithType: Multimaps.<K,V>newMultimap
members:
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Collection<V>>)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
  name: <K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
  nameWithType: Multimaps.<K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
  summary: |-
    Creates a new <code>Multimap</code> backed by <code>map</code>, whose internal value collections are
     generated by <code>factory</code>.

     <p><b>Warning: do not use</b> this method when the collections returned by <code>factory</code>
     implement either <xref uid="List" data-throw-if-not-resolved="false">List</xref> or <code>Set</code>! Use the more specific method <xref uid="#newListMultimap" data-throw-if-not-resolved="false">#newListMultimap</xref>, <xref uid="#newSetMultimap" data-throw-if-not-resolved="false">#newSetMultimap</xref> or <xref uid="#newSortedSetMultimap" data-throw-if-not-resolved="false">#newSortedSetMultimap</xref> instead, to avoid
     very surprising behavior from <xref uid="Multimap#equals" data-throw-if-not-resolved="false">Multimap#equals</xref>.

     <p>The <code>factory</code>-generated and <code>map</code> classes determine the multimap iteration
     order. They also specify the behavior of the <code>equals</code>, <code>hashCode</code>, and <code>
     toString</code> methods for the multimap and its returned views. However, the multimap's <code>get</code>
     method returns instances of a different class than <code>factory.get()</code> does.

     <p>The multimap is serializable if <code>map</code>, <code>factory</code>, the collections generated by
     <code>factory</code>, and the multimap contents are all serializable.

     <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if
     <code>map</code> and the instances generated by <code>factory</code> are. Concurrent read operations will
     work correctly. To allow concurrent update operations, wrap the multimap with a call to <xref uid="#synchronizedMultimap" data-throw-if-not-resolved="false">#synchronizedMultimap</xref>.

     <p>Call this method only when the simpler methods <xref uid="ArrayListMultimap#create()" data-throw-if-not-resolved="false">ArrayListMultimap#create()</xref>, <xref uid="HashMultimap#create()" data-throw-if-not-resolved="false">HashMultimap#create()</xref>, <xref uid="LinkedHashMultimap#create()" data-throw-if-not-resolved="false">LinkedHashMultimap#create()</xref>, <xref uid="LinkedListMultimap#create()" data-throw-if-not-resolved="false">LinkedListMultimap#create()</xref>, <xref uid="TreeMultimap#create()" data-throw-if-not-resolved="false">TreeMultimap#create()</xref>, and <xref uid="TreeMultimap#create(Comparator, Comparator)" data-throw-if-not-resolved="false">TreeMultimap#create(Comparator, Comparator)</xref> won't suffice.

     <p>Note: the multimap assumes complete ownership over of <code>map</code> and the collections
     returned by <code>factory</code>. Those objects should not be manually updated and they should not
     use soft, weak, or phantom references.
  parameters:
  - description: place to store the mapping from each key to its corresponding values
    name: map
    type: <xref href="java.util.Map?alt=java.util.Map&text=Map" data-throw-if-not-resolved="False" />&lt;<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />,<xref href="java.util.Collection?alt=java.util.Collection&text=Collection" data-throw-if-not-resolved="False" />&lt;<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;&gt;
  - description: |-
      supplier of new, empty collections that will each hold all values for a given
           key
    name: factory
    type: <xref href="com.azure.cosmos.implementation.guava25.base.Supplier?alt=com.azure.cosmos.implementation.guava25.base.Supplier&text=Supplier" data-throw-if-not-resolved="False" />&lt;<xref href="? extends java.util.Collection?alt=? extends java.util.Collection&text=Collection" data-throw-if-not-resolved="False" />&lt;<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;&gt;
  syntax: public static Multimap<K,V> <K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
  returns:
    type: <xref href="com.azure.cosmos.implementation.guava25.collect.Multimap?alt=com.azure.cosmos.implementation.guava25.collect.Multimap&text=Multimap" data-throw-if-not-resolved="False" />&lt;<xref href="K?alt=K&text=K" data-throw-if-not-resolved="False" />,<xref href="V?alt=V&text=V" data-throw-if-not-resolved="False" />&gt;
type: method
metadata: {}
package: com.azure.cosmos.implementation.guava25.collect
artifact: com.azure:azure-cosmos:4.3.2-beta.2
