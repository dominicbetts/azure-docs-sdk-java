### YamlMime:JavaMember
uid: com.azure.core.http.rest.PagedFlux.create*
fullName: com.azure.core.http.rest.PagedFlux<T>.<T>create
name: <T>create
nameWithType: PagedFlux<T>.<T>create
members:
- uid: com.azure.core.http.rest.PagedFlux.<T>create(java.util.function.Supplier<com.azure.core.util.paging.PageRetriever<java.lang.String,com.azure.core.http.rest.PagedResponse<T>>>)
  fullName: com.azure.core.http.rest.PagedFlux<T>.<T>create(Supplier<PageRetriever<String,PagedResponse<T>>> provider)
  name: <T>create(Supplier<PageRetriever<String,PagedResponse<T>>> provider)
  nameWithType: PagedFlux<T>.<T>create(Supplier<PageRetriever<String,PagedResponse<T>>> provider)
  summary: "Creates an instance of <xref uid=\"PagedFlux\" data-throw-if-not-resolved=\"false\">PagedFlux</xref> backed by a Page Retriever Supplier (provider).\n When invoked provider should return <xref uid=\"PageRetriever\" data-throw-if-not-resolved=\"false\">PageRetriever</xref>. The provider will be called for each\n Subscription to the PagedFlux instance. The Page Retriever can get called multiple times in serial\n fashion, each time after the completion of the Flux returned from the previous invocation.\n The final completion signal will be send to the Subscriber when the last Page emitted by the Flux\n returned by Page Retriever has <code>null</code> continuation token.\n\n The provider is useful mainly in two scenarios:\n <ul>\n <li> To manage state across multiple call to Page Retrieval within the same Subscription.\n <li> To decorate a PagedFlux to produce new PagedFlux.\n </ul>\n\n <p><strong>Decoration sample</strong></p>\n <pre>\n \n &#47;&#47; Transform a PagedFlux with Integer items to PagedFlux of String items.\n final PagedFlux&lt;Integer&gt; intPagedFlux = createAnInstance&#40;&#41;;\n \n &#47;&#47; PagedResponse&lt;Integer&gt; to PagedResponse&lt;String&gt; mapper\n final Function&lt;PagedResponse&lt;Integer&gt;, PagedResponse&lt;String&gt;&gt; responseMapper\n     = intResponse -&gt; new PagedResponseBase&lt;Void, String&gt;&#40;intResponse.getRequest&#40;&#41;,\n         intResponse.getStatusCode&#40;&#41;,\n         intResponse.getHeaders&#40;&#41;,\n         intResponse.getValue&#40;&#41;\n             .stream&#40;&#41;\n             .map&#40;intValue -&gt; Integer.toString&#40;intValue&#41;&#41;.collect&#40;Collectors.toList&#40;&#41;&#41;,\n         intResponse.getContinuationToken&#40;&#41;,\n         null&#41;;\n \n final Supplier&lt;PageRetriever&lt;String, PagedResponse&lt;String&gt;&gt;&gt; provider\n     = new Supplier&lt;PageRetriever&lt;String, PagedResponse&lt;String&gt;&gt;&gt;&#40;&#41; &#123;\n         &#123;@literal @&#125;Override\n         public PageRetriever&lt;String, PagedResponse&lt;String&gt;&gt; get&#40;&#41; &#123;\n             return &#40;continuationToken, pageSize&#41; -&gt; &#123;\n                 Flux&lt;PagedResponse&lt;Integer&gt;&gt; flux = &#40;continuationToken == null&#41;\n                     ? intPagedFlux.byPage&#40;&#41;\n                     : intPagedFlux.byPage&#40;continuationToken&#41;;\n                 return flux.map&#40;responseMapper&#41;;\n             &#125;;\n         &#125;\n     &#125;;\n PagedFlux&lt;String&gt; strPagedFlux = PagedFlux.create&#40;provider&#41;;\n \n &#47;&#47; Create a PagedFlux from a PagedFlux with all exceptions mapped to a specific exception.\n final PagedFlux&lt;Integer&gt; pagedFlux = createAnInstance&#40;&#41;;\n final Supplier&lt;PageRetriever&lt;String, PagedResponse&lt;Integer&gt;&gt;&gt; eprovider\n     = new Supplier&lt;PageRetriever&lt;String, PagedResponse&lt;Integer&gt;&gt;&gt;&#40;&#41; &#123;\n         &#123;@literal @&#125;Override\n         public PageRetriever&lt;String, PagedResponse&lt;Integer&gt;&gt; get&#40;&#41; &#123;\n             return &#40;continuationToken, pageSize&#41; -&gt; &#123;\n                 Flux&lt;PagedResponse&lt;Integer&gt;&gt; flux = &#40;continuationToken == null&#41;\n                     ? pagedFlux.byPage&#40;&#41;\n                     : pagedFlux.byPage&#40;continuationToken&#41;;\n                 return flux.onErrorMap&#40;t -&gt; new PaginationException&#40;t&#41;&#41;;\n             &#125;;\n         &#125;\n     &#125;;\n final PagedFlux&lt;Integer&gt; exceptionMappedPagedFlux = PagedFlux.create&#40;eprovider&#41;;\n </pre>"
  parameters:
  - description: the Page Retrieval Provider
    name: provider
    type: <xref href="java.util.function.Supplier?alt=java.util.function.Supplier&text=Supplier" data-throw-if-not-resolved="False" />&lt;<xref href="com.azure.core.util.paging.PageRetriever?alt=com.azure.core.util.paging.PageRetriever&text=PageRetriever" data-throw-if-not-resolved="False" />&lt;<xref href="java.lang.String?alt=java.lang.String&text=String" data-throw-if-not-resolved="False" />,<xref href="com.azure.core.http.rest.PagedResponse?alt=com.azure.core.http.rest.PagedResponse&text=PagedResponse" data-throw-if-not-resolved="False" />&lt;<xref href="T?alt=T&text=T" data-throw-if-not-resolved="False" />&gt;&gt;&gt;
  syntax: public static PagedFlux<T> <T>create(Supplier<PageRetriever<String,PagedResponse<T>>> provider)
  returns:
    description: PagedFlux backed by the Page Retriever Function Supplier
    type: <xref href="com.azure.core.http.rest.PagedFlux?alt=com.azure.core.http.rest.PagedFlux&text=PagedFlux" data-throw-if-not-resolved="False" />&lt;<xref href="T?alt=T&text=T" data-throw-if-not-resolved="False" />&gt;
type: method
metadata: {}
package: com.azure.core.http.rest
artifact: com.azure:azure-core:1.7.0
